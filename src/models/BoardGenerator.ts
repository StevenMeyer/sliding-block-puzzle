// This file was generated by AI so we can just start playing
import { Board } from './Board';
import { Direction } from './Direction';

export type Difficulty = 'easy' | 'medium' | 'hard';

type MaybeDirection = Direction | undefined;

/**
 * Generates a winnable board configuration.
 * 
 * The board is guaranteed to be solvable by ensuring blocks are placed
 * such that they can be removed by sliding them toward the edges.
 * 
 * @param height - The height of the board (number of rows)
 * @param width - The width of the board (number of columns)
 * @param difficulty - The difficulty level ('easy', 'medium', or 'hard')
 * @returns A Board instance that is winnable
 */
export function buildWinnableBoard(
  height: number,
  width: number,
  difficulty: Difficulty = 'medium'
): Board {
  if (height < 1 || width < 1) {
    throw new Error('Board dimensions must be at least 1x1');
  }

  // Initialize empty board
  const board: MaybeDirection[][] = Array(height)
    .fill(undefined)
    .map(() => Array(width).fill(undefined));

  // Calculate block count based on difficulty
  const totalCells = height * width;
  const blockCounts = {
    easy: Math.floor(totalCells * 0.2), // ~20% of cells
    medium: Math.floor(totalCells * 0.35), // ~35% of cells
    hard: Math.floor(totalCells * 0.5), // ~50% of cells
  };
  const targetBlocks = Math.max(1, blockCounts[difficulty]);

  // Strategy: All difficulties use the same approach - blocks with clear paths to edges
  // This guarantees winnability. Difficulty is controlled by block count.
  generateBoardWithClearPaths(board, targetBlocks, width, height, difficulty);

  return new Board(board);
}

/**
 * Generates a board with blocks that have clear paths to edges.
 * This strategy guarantees the board is winnable.
 */
function generateBoardWithClearPaths(
  board: MaybeDirection[][],
  targetBlocks: number,
  width: number,
  height: number,
  difficulty: Difficulty
): void {
  let placed = 0;
  let attempts = 0;
  const maxAttempts = width * height * 50; // More attempts for harder difficulties

  while (placed < targetBlocks && attempts < maxAttempts) {
    attempts++;
    const x = Math.floor(Math.random() * width);
    const y = Math.floor(Math.random() * height);

    if (board[y][x] !== undefined) {
      continue;
    }

    const direction = chooseDirection(x, y, width, height, difficulty);

    // Only place if path to edge is clear - this guarantees winnability
    if (hasPathToEdge(x, y, direction, board, width, height)) {
      board[y][x] = direction;
      placed++;
    }
  }
}

/**
 * Chooses an appropriate direction for a block at the given position.
 */
function chooseDirection(
  x: number,
  y: number,
  width: number,
  height: number,
  difficulty: Difficulty
): Direction {
  const distances = {
    toLeft: x,
    toRight: width - 1 - x,
    toTop: y,
    toBottom: height - 1 - y,
  };

  // For easy difficulty, prefer directions toward nearest edge
  if (difficulty === 'easy') {
    const minDistance = Math.min(
      distances.toLeft,
      distances.toRight,
      distances.toTop,
      distances.toBottom
    );

    if (minDistance === distances.toLeft) return Direction.left;
    if (minDistance === distances.toRight) return Direction.right;
    if (minDistance === distances.toTop) return Direction.up;
    return Direction.down;
  }

  // For medium and hard, allow more variety
  const directions: Direction[] = [];
  if (x > 0) directions.push(Direction.left);
  if (x < width - 1) directions.push(Direction.right);
  if (y > 0) directions.push(Direction.up);
  if (y < height - 1) directions.push(Direction.down);

  return directions[Math.floor(Math.random() * directions.length)] || Direction.right;
}

/**
 * Checks if a block at the given position can slide to an edge.
 * This is a simplified check - it verifies there's a path in the direction.
 */
function hasPathToEdge(
  x: number,
  y: number,
  direction: Direction,
  board: MaybeDirection[][],
  width: number,
  height: number
): boolean {
  // Check the path in the direction of the block
  switch (direction) {
    case Direction.left:
      for (let checkX = x - 1; checkX >= 0; checkX--) {
        if (board[y][checkX] !== undefined) {
          return false; // Blocked by another block
        }
      }
      return true; // Path to left edge is clear

    case Direction.right:
      for (let checkX = x + 1; checkX < width; checkX++) {
        if (board[y][checkX] !== undefined) {
          return false; // Blocked by another block
        }
      }
      return true; // Path to right edge is clear

    case Direction.up:
      for (let checkY = y - 1; checkY >= 0; checkY--) {
        if (board[checkY][x] !== undefined) {
          return false; // Blocked by another block
        }
      }
      return true; // Path to top edge is clear

    case Direction.down:
      for (let checkY = y + 1; checkY < height; checkY++) {
        if (board[checkY][x] !== undefined) {
          return false; // Blocked by another block
        }
      }
      return true; // Path to bottom edge is clear

    default:
      return false;
  }
}
